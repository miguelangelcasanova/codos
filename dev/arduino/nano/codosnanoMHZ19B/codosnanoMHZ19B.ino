/*********************************************************************************
CODOS AKA CO2 
Un sistema de bajo coste basado en ESP32 para la detección del CO2 
y otras variables ambientales para monitorizar la calidad del aire en el aula
(o en otros lugares de trabajo)
*********************************************************************************/

#include "Wire.h"                       // Librería Wire para el soporte del protocolo i2c

#include "MHZ19.h"                                        
#include <SoftwareSerial.h>                                // Remove if using HardwareSerial or Arduino package without SoftwareSerial support

#define RX_PIN 2                                          // Rx pin which the MHZ19 Tx pin is attached to
#define TX_PIN 4                                          // Tx pin which the MHZ19 Rx pin is attached to
#define BAUDRATE 9600                                      // Device to MH-Z19 Serial baudrate (should not be changed)

MHZ19 myMHZ19;                                             // Constructor for library

SoftwareSerial mySerial(RX_PIN, TX_PIN);                   // (Uno example) create device to MH-Z19 serial

#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>

#define CO2_sensor_present true         // Debe seleccionarse si este sensor está o no presente
#define OLED_present true              // Debe seleccionarse si la pantalla está o no presente
#define traffic_lights_present true     // Debe seleccionarse si se conectará el semáforo o no (el sensor de CO2 debe estar presente también en ese caso)

// Pines Digitales que he usado en el arduino NANO
#define verde 6
#define amarillo 7
#define rojo 8

#define SCREEN_WIDTH 128 // OLED display width, in pixels
#define SCREEN_HEIGHT 32 // OLED display height, in pixels

// Declaration for an SSD1306 display connected to I2C (SDA, SCL pins)
#define OLED_RESET     4 // Reset pin # (or -1 if sharing Arduino reset pin)
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);

// Imagenes generadas a partir de LCD Assistant (http://en.radzio.dxp.pl/bitmap_converter/)
// con iconos descargados de https://iconarchive.com/ 
const unsigned char PROGMEM happy_icon [] = {
0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xF0, 0x0F, 0xFC, 0x00, 0x00,
0x00, 0x03, 0xF0, 0x00, 0x00, 0x0F, 0xC0, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00,
0x00, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x00,
0x03, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x03, 0xC0, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0,
0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x3F, 0xF0, 0x03, 0xFC, 0x3C, 0x00, 0x0F, 0xFC,
0xF0, 0x00, 0x0F, 0x3C, 0x3C, 0x00, 0x00, 0xFF, 0xC0, 0x00, 0x0C, 0x3F, 0xFC, 0x00, 0x03, 0xC3,
0xC0, 0x00, 0x3C, 0x3C, 0x3C, 0x00, 0x03, 0x03, 0xC0, 0x00, 0x30, 0x30, 0x0C, 0x00, 0x0F, 0x03,
0xC0, 0x00, 0xF0, 0x30, 0x0C, 0x00, 0x0C, 0x03, 0xF0, 0x00, 0xC0, 0xF0, 0x0F, 0x00, 0x3C, 0x0F,
0xF0, 0x03, 0xC3, 0xC0, 0x03, 0xC0, 0x30, 0x0F, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF,
0xF3, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xCF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F,
0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C,
0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x0C, 0x03, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x30,
0x0F, 0x00, 0xF0, 0x00, 0x00, 0x0F, 0x00, 0xF0, 0x03, 0xC0, 0x3C, 0x00, 0x00, 0x3C, 0x03, 0xC0,
0x00, 0xF0, 0x0F, 0xF0, 0x0F, 0xF0, 0x0F, 0x00, 0x00, 0x3C, 0x00, 0x3F, 0xFC, 0x00, 0x3C, 0x00,
0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x03, 0xF0, 0x00, 0x00, 0x0F, 0xC0, 0x00,
0x00, 0x00, 0x3F, 0xF0, 0x0F, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00
};

const unsigned char PROGMEM Angry_icon [] = {
0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xF0, 0x0F, 0xFC, 0x00, 0x00,
0x00, 0x03, 0xF0, 0x00, 0x00, 0x0F, 0xC0, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00,
0x00, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x00, 0x00, 0xF3, 0xF0, 0x00, 0x00, 0x0F, 0xCF, 0x00,
0x03, 0xC0, 0x3F, 0x00, 0x00, 0xFC, 0x03, 0xC0, 0x0F, 0x00, 0x03, 0xF0, 0x0F, 0xC0, 0x00, 0xF0,
0x0C, 0x00, 0x00, 0x30, 0x0C, 0x00, 0x00, 0x30, 0x3C, 0x00, 0x3C, 0x00, 0x00, 0x3C, 0x00, 0x3C,
0x30, 0x00, 0xFF, 0x00, 0x00, 0xFF, 0x00, 0x0C, 0x30, 0x03, 0x00, 0xC0, 0x03, 0x00, 0xC0, 0x0C,
0xF0, 0x03, 0x00, 0xC0, 0x03, 0x00, 0xC0, 0x0F, 0xF0, 0x03, 0x00, 0xC0, 0x03, 0x00, 0xC0, 0x0F,
0xC0, 0x03, 0xC3, 0xC0, 0x03, 0xC3, 0xC0, 0x03, 0xC0, 0x00, 0xFF, 0x00, 0x00, 0xFF, 0x00, 0x03,
0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F,
0x30, 0x00, 0x00, 0x3F, 0xFC, 0x00, 0x00, 0x0C, 0x30, 0x00, 0x0F, 0xF0, 0x0F, 0xF0, 0x00, 0x0C,
0x3C, 0x00, 0x3C, 0x00, 0x00, 0x3C, 0x00, 0x3C, 0x0C, 0x00, 0xF0, 0x00, 0x00, 0x0F, 0x00, 0x30,
0x0F, 0x03, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xF0, 0x03, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x03, 0xC0,
0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x00,
0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x03, 0xF0, 0x00, 0x00, 0x0F, 0xC0, 0x00,
0x00, 0x00, 0x3F, 0xF0, 0x0F, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00
};

const unsigned char PROGMEM Surprised_icon [] = {
0x00, 0x00, 0x00, 0x03, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFF, 0xF0, 0x00, 0x00,
0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x03, 0xC0, 0x00, 0x00, 0x03, 0xC0, 0x00,
0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x30, 0x3F, 0xF0, 0x0F, 0xF0, 0x3C, 0x00,
0x00, 0xC0, 0xF0, 0x30, 0x0C, 0x3F, 0x0F, 0x00, 0x03, 0xC0, 0xC0, 0x00, 0x00, 0x03, 0x03, 0xC0,
0x0F, 0x03, 0xC0, 0x00, 0x00, 0x03, 0xC0, 0xC0, 0x0C, 0x00, 0x0F, 0xC0, 0x03, 0xF0, 0x00, 0x30,
0x0C, 0x00, 0x0F, 0xC0, 0x03, 0xF0, 0x00, 0x30, 0x3C, 0x00, 0x0F, 0xC0, 0x03, 0xF0, 0x00, 0x3C,
0x30, 0x00, 0x0F, 0xC0, 0x03, 0xF0, 0x00, 0x0C, 0x30, 0x00, 0x03, 0x00, 0x00, 0xC0, 0x00, 0x0C,
0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C,
0x30, 0x00, 0x00, 0x03, 0xC0, 0x00, 0x00, 0x0C, 0x30, 0x00, 0x00, 0x3F, 0xFC, 0x00, 0x00, 0x0C,
0x30, 0x00, 0x00, 0xF0, 0x0F, 0x00, 0x00, 0x0C, 0x30, 0x00, 0x03, 0xC0, 0x03, 0xC0, 0x00, 0x0C,
0x3C, 0x00, 0x03, 0x00, 0x00, 0xC0, 0x00, 0x3C, 0x0C, 0x00, 0x0F, 0x00, 0x00, 0xF0, 0x00, 0x30,
0x0F, 0x00, 0x03, 0xFF, 0xFF, 0xC0, 0x00, 0xF0, 0x03, 0x00, 0x00, 0x03, 0xC0, 0x00, 0x00, 0xC0,
0x03, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x03, 0xC0, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x00,
0x00, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00,
0x00, 0x03, 0xF0, 0x00, 0x00, 0x0F, 0xC0, 0x00, 0x00, 0x00, 0x3F, 0xC0, 0x03, 0xFC, 0x00, 0x00,
0x00, 0x00, 0x03, 0xFF, 0xFF, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

const unsigned char PROGMEM Increibles_logo [] = {
0x00, 0x00, 0x00, 0x0F, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xF0, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x7F, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xF8, 0x3F, 0xC0, 0x00, 0x00,
0x00, 0x00, 0x7F, 0xF0, 0x1E, 0x1E, 0x00, 0x00, 0x00, 0x03, 0xFF, 0xC0, 0x1E, 0x00, 0xC0, 0x00,
0x00, 0x1F, 0xFF, 0xC0, 0x1E, 0x00, 0x38, 0x00, 0x00, 0x7F, 0xFF, 0xF0, 0x3E, 0x00, 0x0F, 0x00,
0x01, 0xFF, 0xFF, 0xF8, 0xFC, 0x00, 0x01, 0x80, 0x03, 0xFF, 0xF8, 0x7F, 0xF0, 0x00, 0x00, 0xC0,
0x0F, 0xFF, 0x80, 0x1F, 0xE0, 0x00, 0x00, 0xF0, 0x1F, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78,
0x3F, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x3F, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1E,
0x3F, 0x00, 0x00, 0x00, 0x1C, 0x00, 0x00, 0x1F, 0xFF, 0x00, 0x00, 0x03, 0xFC, 0x00, 0x00, 0x1F,
0xFE, 0x00, 0x00, 0x7F, 0xFC, 0x00, 0x00, 0x1F, 0xFE, 0x00, 0x00, 0x1F, 0xFC, 0x00, 0x00, 0x7F,
0xFC, 0x00, 0x00, 0x1F, 0xFC, 0x00, 0x00, 0x7F, 0xFC, 0x00, 0x00, 0x1F, 0xFC, 0x00, 0x00, 0xFF,
0x3C, 0x00, 0x00, 0x1F, 0xFC, 0x00, 0x00, 0xFE, 0x3C, 0x00, 0x00, 0x1F, 0xFC, 0x00, 0x01, 0xFE,
0x3E, 0x00, 0x00, 0x1F, 0xFC, 0x00, 0x0F, 0xFE, 0x1E, 0x00, 0x00, 0x1F, 0xFC, 0x00, 0x3F, 0xF8,
0x0F, 0x00, 0x00, 0x1F, 0xFC, 0x00, 0xFF, 0xF0, 0x03, 0xC0, 0x00, 0x1F, 0xFC, 0x3F, 0xFF, 0xC0,
0x01, 0xE0, 0x00, 0x1F, 0xFF, 0xFF, 0xFF, 0x80, 0x00, 0x78, 0x00, 0x1F, 0xFF, 0xFF, 0xFF, 0x00,
0x00, 0x1E, 0x00, 0x1F, 0xFF, 0xFF, 0xF8, 0x00, 0x00, 0x03, 0xC0, 0x1F, 0xFF, 0xFF, 0xC0, 0x00,
0x00, 0x00, 0x7C, 0x1F, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00
};

unsigned long getDataTimer = 0;
unsigned long MHZ19B_PREHEATING_TIME = 60000; // Por especificaciones tiene un PREHEATING Time de 3 minutos... pero pongo 1.. 

const int OFFSET_CALIBRATION_TEMP = -6; // Valor obtenido de comparar con un termometro mas fiable que tengo en casa.. NO ES MUY FIABLE
const int OFFSET_CALIBRATION_PPM = -100; // Esta calibracion esta inventada (PENDIENTE) porque supongo que debiera ser unas tablas en funcion de temp y humedad asi que tomo un valor conservador para intentar no generar falsa alarma en el aula.
int p1 = 0; // Variable donde calculo el porcentaje sobre el limite establecido como ROJO
char leyend[15] = "12345678901234"; // Variable donde pongo la leyenda que se pinta en la barra de progreso en funcion del estado
char leyendGREEN[15] = "AULA OK"; 
char leyendRED[15] = "VENTILAR"; 
char leyendYELLOW[15] = "LIMITE KO"; 

void setup() {
  Serial.begin(9600);
  bool status;

  Serial.println("Sensor MHZ19B y OLED 0.96");

  Wire.begin(); //Inialize I2C Hardware
  
  if (OLED_present){
      // SSD1306_SWITCHCAPVCC = generate display voltage
      if(!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) { // Address 0x3C for 128x32
        Serial.println(F("SSD1306 allocation failed"));
        for(;;); // Don't proceed, loop forever
      }     
      // Clear the buffer
      display.clearDisplay();

      // Draw a single pixel in white
      display.drawPixel(10, 10, SSD1306_WHITE);

      // Show the display buffer on the screen. You MUST call display() after
      // drawing commands to make them visible on screen!
      display.display();
      delay(2000);
      Serial.println("OLED Display begin executed");    
  }

  if (CO2_sensor_present){
    mySerial.begin(BAUDRATE);                               // (Uno example) device to MH-Z19 serial start   
    //mySerial.begin(BAUDRATE, SERIAL_8N1, RX_PIN, TX_PIN); // (ESP32 Example) device to MH-Z19 serial start   
    myMHZ19.begin(mySerial);                                // *Serial(Stream) refence must be passed to library begin(). 

    myMHZ19.autoCalibration();                              // Turn auto calibration ON (OFF autoCalibration(false))    
 } 

 if (OLED_present) {
    display.setTextSize(1);             // Normal 1:1 pixel scale
    display.setTextColor(SSD1306_WHITE); 
    int percentage; 
    while (millis() < MHZ19B_PREHEATING_TIME) {
      percentage = millis()*100/MHZ19B_PREHEATING_TIME;
      display.clearDisplay();
      if (percentage < 10) {
        display.drawBitmap(32,0,Increibles_logo,64,32,1);
      } else {
        display.setCursor(0,0);             // Start at top-left corner
        display.setTextSize(2);
        display.setTextColor(WHITE);
        display.println(F("PREHEAT..."));
        display.setCursor(60,18);             // Start at top-left corner
       
        drawPercentbar( 1, 17, SCREEN_WIDTH-10, 15,percentage, false, leyend);       
      }
      display.display();
      delay(1000);       
    }
 }

  pinMode(verde, OUTPUT);
  pinMode(amarillo, OUTPUT);
  pinMode(rojo, OUTPUT);  
  // Apagar los led al empezar
  digitalWrite(verde, LOW);
  digitalWrite(amarillo, LOW);
  digitalWrite(rojo, LOW);
}

int ppm_uart = 0; // Variable donde vuelco el valor CO2 obtenido del MHZ19B
int temperature = 0; // Variable donde vuelco el valor temperatura obtenido del MHZ19B
const int CO2_safe_level = 500;        // Se debe especificar un valor máximo de CO2 seguro
const int CO2_alarm_level = 1100;       // Se debe especificar un valor máximo de CO2 de alarma

// Tipos y variables para controlar el estado del semaforo y las acciones asociadas
typedef enum {
  GREEN = 1, 
  YELLOW = 2, 
  RED = 3
} SEMAPHORE_TYPE;

SEMAPHORE_TYPE currentState = GREEN;
SEMAPHORE_TYPE lastState = RED;

bool showImage = false; // Variable que indicara si hay que mostrar imagen de smiley
const unsigned long NUM_CYCLES_SHOW_DATA = 10; // muestro datos lecturas durante 10 lecturas ppm
const unsigned long NUM_CYCLES_IMAGE = 2; // muestro smiley durante dos lecturas ppm en segundo plano
unsigned long cycles = 0;
void loop() {
  
  if (CO2_sensor_present) {
    
    if (millis() - getDataTimer >= 2000) {
      getDataTimer = millis();
      int ppm_uart_read = myMHZ19.getCO2()+OFFSET_CALIBRATION_PPM;
      int temperature_read = myMHZ19.getTemperature()+OFFSET_CALIBRATION_TEMP;
      bool newData = false;
      
      if ((ppm_uart_read > 0) && (ppm_uart != ppm_uart_read)) {
        ppm_uart = ppm_uart_read;
        newData = true;
      }
      
      if ((temperature_read > 0) && (temperature != temperature_read)) {
        temperature = temperature_read;
        newData = true;
      }

      // Una razon de newData = true tb es que pasemos a mostrar la imagen o no del smiley (pensar otra forma menos chapucera de hacerlo)
      cycles++;
      if ((!showImage) && ((cycles % NUM_CYCLES_SHOW_DATA) == 0)) {
        cycles = 0; 
        showImage = true; 
        newData = true;
      } else if ((showImage) && ((cycles % NUM_CYCLES_IMAGE) == 0)) {
        cycles = 0; 
        showImage = false;
        newData = true;
      } else if (currentState != lastState) {
        cycles = 0;
        showImage = true;
        lastState = currentState;
        switch (currentState) {
          case GREEN : 
            strcpy(leyend,leyendGREEN); break;
          case RED :
            strcpy(leyend,leyendRED); break;
          case YELLOW :
            strcpy(leyend,leyendYELLOW); break;
        }
        newData = true;
      }
      

      if (newData == true) {
        p1 = ppm_uart*100/CO2_alarm_level;
         
        if (OLED_present){
          if (!showImage) {
            display.clearDisplay();
            display.setTextSize(2);
            display.setTextColor(SSD1306_WHITE); 
            display.setCursor(5,3);
            display.drawRect(1, 0, 49, 20, WHITE);
            display.drawRect(50, 0, 78, 20, WHITE);
            display.drawRect(105, 0, 23, 10, WHITE);
            display.print(temperature, DEC); 
            display.setTextSize(1);
            display.print(F("*"));
            display.setTextSize(2);
            display.print(F("C"));
            if (ppm_uart > 1000){
              display.setCursor(55,3);            
            } else {
              display.setCursor(60,3);
            }
            display.print(ppm_uart, DEC);
            display.setTextSize(1); 
            display.setCursor(108,2);
            display.print(F("PPM")); 
            drawPercentbar( 1, 19, 127, 13,p1,true,leyend);
            display.display();
            traffic_lights(ppm_uart);
          } else { traffic_lights(ppm_uart);
          }
        }
         
      } // if (newData == true)
    } // if (millis() - getDataTimer >= 2000)  
  } // if (CO2_sensor_present)
    
  delay(1000);
}

void drawPercentbar(int x,int y, int width,int height, int progress, bool customLeyend, char *strCustomLeyend)
{
   int ppm = progress;
   progress = progress > 100 ? 100 : progress;
   progress = progress < 0 ? 0 :progress;

   float bar = ((float)(width-4) / 100) * progress; 

   display.drawRect(x, y, width, height, WHITE);
   display.fillRect(x+2, y+2, bar , height-4, WHITE);

   // Display progress text
   if( height >= 13){
      display.setCursor((width/2) -3, y+5 );
      display.setTextSize(1);
      display.setTextColor(WHITE);

      if( progress >=50) {
         display.setTextColor(BLACK, WHITE); // 'inverted' text
      }
      if (!customLeyend) {
        display.print(progress);
        display.print("%");      
      } else {
        switch (currentState) {
          case GREEN :
            display.setTextColor(WHITE);
            display.setCursor((width/2) +10, y+3 );
            break;
          case YELLOW :          
            display.setTextColor(BLACK, WHITE);
            display.setCursor(x+3, y+3 );
            break;
          case RED :          
            display.setTextColor(BLACK, WHITE);
            display.setCursor(x+3, y+3 );
            break;
        }
        display.print(strCustomLeyend);
      }
   }
}

void traffic_lights(int CO2_value){
      
  Serial.println(CO2_value);
  if (CO2_value <= CO2_safe_level){
    // Encender el led verde y apagar el resto
    Serial.println("Parece que el aula no necesita más ventilación de momento");
    digitalWrite(verde, HIGH);
    digitalWrite(amarillo, LOW);
    digitalWrite(rojo, LOW);
    currentState = GREEN;
    if (showImage) {
      display.clearDisplay();
      display.drawBitmap(32,0,happy_icon,64,32,1);
      display.display();
    }
  } 
  if ((CO2_value > CO2_safe_level) & (CO2_value < CO2_alarm_level)) {
    // Encender el led amarillo y apagar el resto
    Serial.println("El aire del aula necesitará renovarse pronto");
    digitalWrite(verde, LOW);
    digitalWrite(amarillo, HIGH);
    digitalWrite(rojo, LOW);
    currentState = YELLOW;
    if (showImage) {
      display.clearDisplay();
      display.drawBitmap(32,0,Surprised_icon,64,32,1);
      display.display();
    }
  }
  if (CO2_value >= CO2_alarm_level){
    // Encender el led rojo y apagar el resto
    Serial.println("Habría que ventilar el aula");
    digitalWrite(verde, LOW);
    digitalWrite(amarillo, LOW);
    digitalWrite(rojo, HIGH);
    currentState = RED;
    if (showImage) {
      display.clearDisplay();
      display.drawBitmap(32,0,Angry_icon,64,32,1);
      display.display();
    }       
  }
}

